# Лабораторная работа №1

## Тема: Указатели

### Задача 1 - упражнения с malloc и сложными однострочными выражениями в C с присваиваниями внутри

#### Постановка задачи:
Внутри функции int main(void) { /\*...\*/ } определите указатель: 
double \*\*\*pointer = NULL; 
Инициализируйте этот указатель адресом другого указателя типа double \*\*, который указывает, в свою очередь, на переменную double. Используйте pointer для записи и чтения в эту переменную значения 2. 
При этом выполните следующее: - Используйте функции типа \*alloc(...) для выделения оперативной памяти под динамические объекты; - Запишите и выведите число 2 на экран, используя указатель double \*\*\*pointer = NULL;; - Используйте функцию free(...) для освобождения оперативной памяти, выделенной под динамические объекты. 
-Не используйте никаких идентификаторов переменных, кроме pointer.

#### Список идентификаторов

| Имя переменной | Тип данных | Описание и смысл                                                  |
|----------------|------------|-------------------------------------------------------------------|
| pointer        | double     | при тройном разыменовании(***) хранит значение 2.0                |
| pointer        | double*    | 1 разыменование pointer, хранит адрес переменной со значением 2.0 |
| pointer        | double**   | 2 разыменование, хранит переменную со значением 2.0               |
| pointer        | double***  | 2 разыменование, хранит значение 2.0                              |

#### Код программы
```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

double ***pointer = NULL;

// далее выделяем память на адреса и переменную
pointer = (double***)malloc(sizeof(double**)); // хранит адрес адреса переменной
*pointer = (double**)malloc(sizeof(double*)); // хранит адрес переменной с нашим значением
**pointer = (double*)malloc(sizeof(double)); //хранит значение переменной
***pointer = 2.0; // собственно, присваиваем само значение переменной

printf("%.1f \n", ***pointer);

// далее освобождаем память в обратном порядке, с "малого", чтобы не потерять данные
free(**pointer); 
free(*pointer);
free(pointer);

return 0;
}
```
#### Результат выполнения программы
<img width="1424" height="334" alt="4c1293eb9a3bb74540c8aab9b2ea84da" src="https://github.com/user-attachments/assets/1d5333b6-42fd-464c-8ffc-8f6209410976" />


### Задача 2 - итерация массива с помощью арифметики указателей

#### Постановка задачи
Напишите программу, которая создает одномерный динамический массив из чисел с плавающей точкой двойной точности, заполняет его значениями с клавиатуры и выводит все элементы массива, используя арифметику указателей (оператор +), а не оператор доступа к элементам массива [].

#### Список идентификаторов

| Имя переменной | Тип данных | Описание и смысл                                                                                 |
|----------------|------------|--------------------------------------------------------------------------------------------------|
| len            | int        | длина вводимого массива                                                                          |
| arr            | double*    | массив, эл-ты которого вводятся с клавиатуры                                                     |
| i              | int        | параметр циклов, как счётчик элементов и как переход от элемента к элементу в сумме с указателем |

#### Код программы
```c
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>

int main(void) {

int len;
double *arr;

printf("Введите длину массива: ");
scanf("%d", &len );

arr = (double*)malloc(len * sizeof(double)); // выделяем память на массив длины len

// далее проверяем успешность выделения памяти
if (arr == NULL){
    printf("Ошибка выделения памяти!\n");
    return 1;
}

printf("Введите элементы массива: \n");
// с помощью указателя вводим значения элементов массива, перемещаяcь по элементам прибавлением i
for (int i = 0; i < len; i++){ 
    scanf("%lf", arr + i);
}

// таким же образом перебираем готовые элементы и выводим их, разыменовывая указатель
printf("Введённый вами массив: \n");
for (int i = 0; i < len; i++){
    printf("%.2lf ", *(arr + i));
}

free(arr);// освобождаем память 
return 0;
}
```

#### Результат работы программы
<img width="1422" height="420" alt="f6cb1b3e74348f2ebd06b1943ba68245" src="https://github.com/user-attachments/assets/8112ef52-ae65-472d-ae1e-8dba66fd19be" />

### Задача 3 - динамический 2D массив
#### Постановка задачи
Выделите память под двумерный динамический массив двумя способами:
1. Классический способ: выделите память для массива указателей на строки и отдельно для каждой строки в цикле. Это позволит гибко управлять памятью, но при этом каждая строка будет находиться в отдельной части памяти.
2. Непрерывный способ (contiguous memory allocation): выделите память для всего массива одним вызовом malloc, что позволит разместить весь массив в непрерывном блоке памяти, улучшая производительность и снижая риск внешней фрагментации памяти.
После выполнения программы обязательно корректно освободите всю выделенную оперативную память с помощью free().
Оба метода имеют свои преимущества и недостатки. При непрерывном выделении (contiguous allocation) вся память выделяется в одном блоке, что уменьшает вероятность фрагментации, но может усложнить управление при необходимости изменения размеров массива.
#### Список идентификаторов

| Имя переменной | Тип данных | Описание и смысл                                 |
|----------------|------------|--------------------------------------------------|
| rows           | int        | количество строк в матрице (двумерном массиве)   |
| cols           | int        | количество столбцов в матрице(двумерном массиве) |
| arr            | int**      | двумерный массив из указателей                   |
| i              | int        | параметр цикла, отвечает за перебор строк        |
| j              | int        | параметр цикла, отвечает за перебор столбцов     |

#### Код программы
1 способ:
```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {

int rows, cols;
printf("Введите количество строк в матрице: ");
scanf("%d", &rows);

printf("Введите количество столбцов в матрице: ");
scanf("%d", &cols);

int **arr = (int **)malloc(rows * sizeof(int*)); // выделили память на массив указателей

if (arr == NULL){ // проверили успех выделения памяти
    printf("Ошибка выделения памяти на массив с указателями(матрицу)!\n");
    return 1;
}

for (int i = 0; i < rows; i++){
    arr[i] = (int *)malloc(cols * sizeof(int));

    if (arr[i] == NULL){ // снова проверили память
    printf("Ошибка выделения памяти на строку %d!\n", i+1);
        for (int j = 0; j < i; j++) // если неудачно, то освобождаем всё выделенное ранее
            free(arr[j]);
        free(arr);
        return 1;

    }
}

for (int i = 0; i < rows; i++){ // заполнение построчно
    printf("Введите %d элементов %d строки: ", cols, i+1);
    for (int j = 0; j < cols; j++)
        scanf("%d", &arr[i][j]);
}

printf("Введённая вами матрица: \n"); // вывод матрицы
for (int i = 0; i < rows; i++){
        for (int j = 0; j < cols; j++){
            printf("%d\t", arr[i][j]);
        }
        printf("\n");
    }
for (int i = 0; i < rows; i++){ // очищение памяти строк, потом всего массива указателей
    free(arr[i]);
    }
free(arr);

return 0;
}
```
2 способ: 
```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int rows, cols;
    double *arr;

    printf("Введите количество строк: ");
    scanf("%d", &rows );

    printf("Введите количество столбцов: ");
    scanf("%d", &cols );

    int total = rows*cols;
    arr = (double*)malloc(total * sizeof(double)); // выделяем память на массив единой функцией

    // проверяем успешность выделения памяти
    if (arr == NULL){
        printf("Ошибка выделения памяти!\n");
        return 1;
    }

    int num_cols = 0;
    // с помощью указателя вводим значения элементов массива + вводим построчно
    for (int i = 0; i < (rows*cols); i++){ 
        if (i % (cols) == 0){
            num_cols++;
            printf("Введите через пробел элементы %d строки: ", num_cols);
        }
        scanf("%lf", arr + i);
    }

    // таким же образом выводим их построчно, разыменовывая указатель
    printf("Введённая вами матрица: \n");
    for (int i = 0; i < (rows*cols); i++) {
        if (i % (cols) == 0){
            printf("\n");
        }
        printf("%.3f\t", *(arr + i)); 
    }
        
    free(arr);// освобождаем память 
    return 0;
}
```
#### Результат выполнения программы
1 способ:
<img width="1454" height="420" alt="8018953c59dbaa08d2d810d8055397c6" src="https://github.com/user-attachments/assets/fe9a6830-5c3c-4521-a995-224f044dbdfe" />


2 способ:
<img width="1064" height="471" alt="72defabc2686d20fda8964bf26eaffc6" src="https://github.com/user-attachments/assets/447c3a37-212d-416f-99f8-05d8f56e6019" />


### Задача 4 - поменять местами 2 числа через указатели


#### Постановка задачи
Написать программу, которая использует функцию для обмена значениями двух переменных через указатели.
#### Список идентификаторов
| Имя переменной | Тип данных | Описание и смыл                                        |
|----------------|------------|--------------------------------------------------------|
| a              | int        | Вводимое число                                         |
| b              | int        | Вводимое число                                         |
| x              | int*       | Указатель, принимающий значение переменной a в функции |
| y              | int*       | Указатель, принимающий значение переменной b в функции |
| add            | int        | Промежуточная переменная для обмена                    |

#### Код программы
```c
#include <stdio.h>

void swap(int *x, int *y){ //функция для обмена значений переменных, принимает их адреса. Через 
    int add;			   // указатели меняет местами значения переменных по этим адресам.
    add = *y;
    *y = *x;
    *x = add;
}

int main(){

int a, b;

printf("Введите 2 изначальных числа: \n");
printf("a =: ");
scanf("%d", &a);

printf("b =: ");
scanf("%d", &b);

swap(&a, &b); // вызов функции > обмен значений 

printf("Теперь a = %d, b = %d", a, b);

return 0;
}
```

#### Результат работы программы
<img width="1084" height="320" alt="fff504e42b22c06ab6070e5cc967e2cc" src="https://github.com/user-attachments/assets/5897a06d-7b3a-439b-91e2-5c6057af1b0d" />

### Задача 5 - поиск максимального элемента массива с помощью указателей
#### Постановка задачи
Создать функцию, которая принимает массив целых чисел и его размер, а затем возвращает указатель на максимальный элемент массива.
#### Список идентификаторов
| Имя переменной | Тип данных | Описание и смысл                                      |
|----------------|------------|-------------------------------------------------------|
| len            | int        | Длина массива(размер)                                 |
| arr            | int        | Массив, вводимый с клавиатуры                         |
| i              | int        | Параметр цикла                                        |
| n              | int        | Переменная в функции, значение длины массива len      |
| mass           | int        | Массив в функции, принимает значение arr              |
| max_t          | int*       | Указатель на максимальный элемент в функции           |
| max_el         | int*       | Указатель на максимальный элемент, выводимый на экран |

#### Код программы
```c
#include <stdio.h>
#include <stdlib.h>

int* func(int mass[], int n){ \\ функция ищет макс элемент, 	int *max_t = mass;		  \\ записывая его в указатель
	for (int i = 1; i < n; i++){
		if (mass[i] > *max_t){
			max_t = &mass[i];
		}
	}
	return max_t;
}

int main(){

int len;
printf("Введите длину массива: ");
scanf("%d", &len);

int *arr = (int*)malloc(len*sizeof(int)); \\ выделение памяти
if (arr == NULL){
	printf("Ошибка выделения памяти на массив!");
	return 1;
}
printf("Введите через пробел элементы массива:\n");
for (int i = 0; i < len; i++){
	scanf("%d", arr + i);
}

if (max_el == NULL){
    printf("Ошибка нахождения результата функции!");
    return 1;
}
int *max_el = func(arr, len); \\вызов функции
printf("Максимальный элемент массива = %d", *max_el);

free(arr);
return 0;
}
```

#### Результат работы программы
<img width="1086" height="526" alt="5abab5fc1567006c4a53b9231f018c2e" src="https://github.com/user-attachments/assets/0b1c5179-ea8b-44c7-a441-4959ca7dd9cd" />

### Задача 6 - реверс массива через указатели
#### Постановка задачи
Реализовать функцию, которая переворачивает массив целых чисел, используя указатели для перемещения по элементам.
#### Список идентификаторов
| Имя переменной | Тип данных | Описание и смысл                                    |
|----------------|------------|-----------------------------------------------------|
| len            | int        | Длина массива                                       |
| arr            | int        | Массив, вводимый с клавиатуры                       |
| i              | int        | Параметр цикла                                      |
| start          | int*       | Указатель (изначально на начальный элемент массива) |
| end            | int*       | Указатель (изначально на конечный элемент массива)  |
| temp           | int        | Промежуточная переменная для обмена значений        |
#### Код программы
```c
#include <stdio.h>
#include <stdlib.h>

void reverse(int *start, int *end){ \\функция переворачивания массива
									\\ двигаются указатели от крайних элементов к середине массива, 											меняя попарно числа местами
	while(*start < *end){
		int temp = *start;
		*start = *end;
		*end = temp;
		start++;
		end--;
	}
}

int main()
{

int len;
printf("Введите длину массива: ");
scanf("%d", &len);

int *arr = (int *)malloc(len * sizeof(int));
if (arr == NULL){
	printf("Ошибка выделения памяти на массив!");
	return 1;
}

printf("Введите через пробел элементы массива: ");
for (int i = 0; i < len; i++){
	scanf("%d", arr + i);
}

reverse(&arr[0], &arr[len - 1]); \\ вызов функции

printf("Перевёрнутый массив: ");
for (int i = 0; i < len; i++){
	printf("%d ", *(arr + i));
}
free(arr);
return 0;

}
```
#### Результат выполнения программы
<img width="1074" height="304" alt="8c30154e398b9dab7afa3ca447d32e28" src="https://github.com/user-attachments/assets/dd44a3fa-d35d-4e34-880f-4b05790d5f82" />


### Задача 7 - поиск подстроки в строке через указатели
#### Постановка задачи
Реализовать функцию, которая находит первое вхождение одной строки в другую, используя указатели вместо индексов для доступа к символам строки.
#### Список идентификаторов
| Имя переменной | Тип данных  | Описание и смысл                                                                    |
|----------------|-------------|-------------------------------------------------------------------------------------|
| str            | const char* | указатель на основную строку                                                        |
| sub_str        | const char* | указатель на подстроку, которую будем искать                                        |
| main_ptr       | const char* | указатель на начало основной строки                                                 |
| main_temp      | const char* | временный указатель на текущее положение в основной строке (для перебора элементов) |
| sub_temp       | const char* | временный указатель на подстроку (для перебора элементов)                           |
| res            | char*       | указатель на результат нахождения вхождения подстроки в строку                      |
| position       | int         | индекс = позиция первого символа подстроки в строке                                 |

#### Код программы
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

char* first_entry(const char *str, const char *sub_str) {
    
    const char *main_ptr = str; // указатель на начало основной строки

    while (*main_ptr != '\0') {
        const char *main_temp = main_ptr;  // временный указатель на текущую позицию в основной строке
        const char *sub_temp = sub_str;     // временный указатель на подстроку
            
         // тут сравниваем соответствующие символы, пока они совпадают и пока не конец подстроки
        while (*main_temp == *sub_temp && *sub_temp != '\0') {
            main_temp++;
            sub_temp++;
        }
        // дошли до конца подстроки = нашли совпадение со всей подстрокой
        if (*sub_temp == '\0') {
            return (char*)main_ptr;  // возвращаем указатель на начало найденной подстроки
        }
        main_ptr++; 
    }
return NULL;  // если ничего не нашли
} 	

void print_res(const char* str, const char* sub_str) { \\ функция красивого вывода результата
    char *res = first_entry(str, sub_str);

    int position = res - str;

    printf("Основная строка: ");
    fputs(str, stdout);
    printf("\n");

    printf("Подстрока, которую ищем: ");
    fputs(sub_str, stdout);
    printf("\n");
    
    if (res != NULL){
        printf("Позиция первого вхождения: %ld\n", position);
        printf("\n");
    }
    else {
        printf("Не найдено\n");
        printf("\n");
    }
}

int main() { \\ функция тестирования различных строк
	
    print_res("Hello, little onion", "on");
    print_res("Hello, little onion", "o");
    print_res("aaaaaaababaaaaa", "aba");
    print_res("I_Love_C", "I");
    print_res("I_Love_C", "C");
    print_res("abcabcabcabc", "xyz");
    
    return 0;
}
```
#### Результат выполнения программы
<img width="972" height="822" alt="00209c836285873a62168c1a8c3a4e8d" src="https://github.com/user-attachments/assets/38e04fd8-d2ee-42ee-92ea-9c882de1c08f" />


### Задача 9 - подсчёт числа пробелов в строке  

#### Постановка задачи
Написать функцию, которая подсчитывает количество пробелов в строке, используя указатели для перемещения по
символам строки.
#### Список идентификаторов
| Имя переменной | Тип данных  | Описание и смысл                                                |
|----------------|-------------|-----------------------------------------------------------------|
| str            | const char* | Указатель на строку                                             |
| count          | int         | Количество пробелов в строке - результат в функции счёта        |
| res            | int         | Количество пробелов в строке - результат выполнения (выводимый) |

#### Код программы
```c
#include <stdio.h>
#include <string.h>

int space_count(const char* str){ \\ функция подсчёта пробелов

    int count = 0;

    int len_str = strlen(str);

    while (*str != '\0'){
        if (*str == ' '){
            count++;
        }
        str++;
    }
    return count;
}

void print_res(const char *str){ \\ функция вывода результатов
    printf("Строка: ");
    fputs(str, stdout);
    printf("\n");
    
    int res = space_count(str);
    printf("Пробелов в этой строке: %d\n", res);
    printf("\n");

}

int main(){ \\ функция тестирования различных строк

    print_res("Hello world hi");    
    print_res("Helloworldhi");    
    print_res("m a n y s p a c e s");    
    print_res(" startfinish "); 
    print_res("  ");    

return 0;
}
```
#### Результат выполнения программы
<img width="1296" height="570" alt="ea873aa28f2194058a4827ddfd3be2f2" src="https://github.com/user-attachments/assets/9895c8df-0941-413b-8a24-ad8b756daee8" />

### Выполнила: Жукова София 1об ПОО
